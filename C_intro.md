# 初めてのC言語（コンパイラ言語）

- 取り組み方に関する補足
  - 例題1〜4にはコード例が記載されている。
  - まずはそのままのコードを実行してみよう。
  - 実行できたら、一部編集してみてコンパイル＆実行してみよう。
    - e.g.,
      - セミコロンが無かったらどうなるだろうか？
      - インデントがずれてるとどうなるだろうか？
      - どういう時にどういうエラー・警告がでるのか、それとも問題ないのか、を確認しながら取り組んでみよう。この手間を惜しむと、ゼロからコードを書く際に「**コンパイラが出す警告・エラーの意味**」が分からず、コードをどのように修正すべきかを判断できないことになります。
  - C言語に限らず、新しい言語について学ぶ際にはいろいろいじって動作確認する癖を付けよう。

<ul>
<lh>＜目次＞</lh>
<li><a href="#goal">達成目標</a>
<li><a href="#compiler_interpreter">コンパイラ言語とインタプリタ言語</a>
<li><a href="#static_dynamic_type">静的型付け言語と動的型付け言語</a>
<li><a href="#tutorial">C言語チュートリアル</a>
<ul>
<li><a href="#ex1">例題1: 四則演算結果を標準出力してみよう。</a>
<li><a href="#ex2">例題2: シーケンス集合を利用してみよう。（配列とfor文、if文）</a>
<li><a href="#ex3">例題3: 関数を作成してみよう。</a>
<li><a href="#ex4">例題4: 構造体を利用してみよう。</a>
</ul>
<li><a href="#ref">参考サイト</a>
</ul>

<hr>

## <a name="goal">達成目標</a>
- コード例をコンパイルし、実行できる。
- コード例を編集し、利用できる。
- 静的型付け言語であることを理解して、コードを記述できる。
- 基本構文（if, for, while）と関数を利用できる。
- 配列を利用することができる。
- 構造体を利用することができる。
- オンライン・マニュアル(man)を参照することができる。

<hr>

## <a name="compiler_interpreter">コンパイラ言語とインタプリタ言語</a>
- 参考サイト
  - [Wikipedia:インタプリタ](https://ja.wikipedia.org/wiki/インタプリタ)
  - [Wikipedia:コンパイラ](https://ja.wikipedia.org/wiki/コンパイラ)
- コンパイラ
  - プログラミング言語で記述されたプログラムを、機械語（や中間言語）に変換するプログラムのこと。
  - コンパイラ言語は **「コード作成（編集）」->「コンパイラで機械語に翻訳」->「生成された実行可能ファイルを実行」** という手順を繰り返して開発作業を行う。
  - 言語例
    - C言語(C++, C#, Objective-C), Java,,,
- インタプリタ
  - プログラミング言語で記述されたプログラムを、コードを読みながらその都度解釈して実行するプログラムのこと。
  - インタプリタ言語は **「コード作成（編集）」->「インタプリタでコードを直接実行」** という手順を繰り返して開発作業を行う。
  - 言語例
    - Python, Perl, Ruby,,,
- 一般的な違い
  - 例外多数あり。
    - 例えば Python は、C言語やJava に比べると遅いが、numpyモジュールの内部はC言語で記述されており、行列演算に限定すると速度差は殆ど無い。
    - 例えば Swift は、コンパイラ言語でありながらインタプリタとしての実行も可能。

|特徴|実行時の違い|実行速度|コードの隠蔽具合|実行までの手間|
|---:|:---|:---|:---|:---|
|インタプリタ|実行を伴う|遅い|丸見え（変更しやすい・細工されやすい）|特に無い（その場でインタプリタが全てやってくれる）|
|コンパイラ|実行を伴わない|早い|ソースコード無くても動く（変更しにくい・細工されにくい）|実行形式のファイルを作成する必要がある（コンパイルする手間が必要＝コンパイルできないと実行もできない）|

<hr>

## <a name="static_dynamic_type">静的型付け言語と動的型付け言語</a>
- 参考サイト
  - [静的型付き言語プログラマから見た動的型付き言語](http://d.hatena.ne.jp/kazu-yamamoto/20130308/1362724125)
- 動的型付け言語
  - 変数の型は実行時に確定する。（動的に型が決定される）
    - メリット: インタプリタのメリットとほぼ同じ？
    - デメリット: 実行するまで型を確定できない（テスト量が増えることが多い）。実行時に型推論をするコストがかかる（から遅くなることが多い）。
- 静的型付け言語
  - 予め型を指定しておく。（品質を保証しやすい）

<hr>

## <a name="tutorial">C言語チュートリアル</a>
- 参考サイト
  - [paiza:C言語入門](https://paiza.jp/works/c/primer): 数分動画＋演習形式
  - [初心者のためのポイント学習Ｃ言語](http://www9.plala.or.jp/sgwr-t/index.html)
  - [苦しんで覚えるＣ言語(苦Ｃ)](http://9cguide.appspot.com)
  - C言語/ポインタ編（詳細は「アルゴリズムとデータ集合」にて）
    - [ポインタ虎の巻](http://www.nurs.or.jp/~sug/soft/tora/)
  - マニュアル: [【 man 】 オンライン・マニュアルを参照する](http://itpro.nikkeibp.co.jp/article/COLUMN/20060227/230821/)

<hr>

### <a name="ex1">例題1: 四則演算結果を標準出力してみよう。</a>
- Pythonでの例: ex1.py
  - 動かし方
    - ex1.py というファイルに保存したのなら、ターミナル上で ``python ex1.py`` と実行。

```
# a+bの結果を標準出力するコード。
a = 1
b = 2
result = a + b
print('{0} + {1} = {2}'.format(a,b,result))
```

- Cコード例: ex1.c
  - 動かし方
    - ex1.cというファイル名で以下のコードを保存。
    - コンパイル。
      - ターミナル上で ``gcc ex1.c`` か、``gcc ex1.c -o ex1`` と実行。前者だと「a.out」という名前の実行ファイルが生成される。後者だと「ex1」という名前で生成される。（実行ファイルの名前を指定したい場合に **-o オプション** を使う）
      - コンパイル時にエラーが出たら、そのエラーが無くなるまで編集する必要あり。（実行ファイルが生成されないと実行できない）
    - 実行。
      - ターミナル上で実行ファイル名を指定して実行。a.outなら ``./a.out`` とパス付きで実行すること。

```
/* a+bの結果を標準出力するコード。 */
#include <stdio.h>

int main(){
    int a = 1;
    int b = 2;
    int result = a + b;
    printf("%d + %d = %d\n",a,b,result);
    return 0;
}
```

- コード比較: Python vs C
  - ``/* a+bの結果を標準出力するコード。 */``
    - コメント行。1行なら ``//``を頭につけても良い。
  - ``#include <stdio.h>``
    - stdio(標準入出力)を利用する関数（ここではprintf()のこと）を利用するための命令。（Pythonにおけるimport相当）
  - ``int main(){〜〜〜}``
    - 実行するコードは、 **main()関数** 内に書く必要がある。main()関数外にあるコードは、main()関数から呼ばれた時だけ実行される。（main()関数からしか実行されない）
    - 関数は戻り値の型を指定する必要がある。
      - 代表的な型
        - int, long int
        - float, double
        - char: character型(文字型)。文字列型ではない点に注意。
        - void: 型なし。（＝戻り値無し）
    - ブロックは ``{}`` （brace; ブレース)で囲う。
    - ``int a = 1;``
      - 変数を利用する前に **型を指定して宣言** する必要がある。
      - 上記の文は「宣言」した上で「初期化」している。これを2つに分解して記述することも可能。
        - ``int a; a = 1;``
        - C言語ではインデントは比較的自由に記述できる。
          - インデントが無いコードは「可読性が低い」ため、原則として禁止。適切にインデントを入れよう。（インデントが書かれていないだけで大幅減点する先生もいます。人間が読みやすいように作られている言語だから、可読性を意識して書こう）
      - 文の終わりには ``;`` (semi-colon; セミコロン) を書く必要がある。
  - ``printf("%d + %d = %d\n",a,b,result);``
    - ``%d``は「10進数表記」で出力しろという指定。
      - ``%d``, ``%ld``: 10進数表記。
      - ``%o``: 8進数表記。
      - ``%x``: 16進数表記。
      - ``%f``, ``%lf``: 浮動小数点数表記。
      - ``%c``: 文字表記。
      - ``%s``: 文字列表記。
    - **マニュアルの使い方**
      - ターミナルで``man 3 printf``を実行してみよう。
        - 「man」はUNIXシステムの標準マニュアルを読むためのコマンド。
          - 「man man」とすると、manコマンドについて調べることができる。（引数で調べたいコマンド等を指定する）
        - 「3」はセクション番号。1だとコマンド、2だとシステムコール、3は主に関数について記述されている。
          - ``man printf`` とセクション番号を省略して実行すると、セクション1から順番に探していき、はじめに見つかったセクションのマニュアルを表示する。同名のコマンド・関数は多数あるため、C言語の関数について調べる時はセクション3を指定して実行するほうが良い。
      - 参考: [【 man 】 オンライン・マニュアルを参照する](http://itpro.nikkeibp.co.jp/article/COLUMN/20060227/230821/)
  - ``return 0;``
    - main()関数の戻り値はint型だと指定されている。プログラム終了時には何かしらint型の値を返す必要がある（＝終了ステータス）。
      - 終了ステータスが0だと「特に問題なくプログラムの実行が終了した」という意味で使われることが多い。

<hr>

### <a name="ex2">例題2: シーケンス集合を利用してみよう。（配列とfor文、if文）</a>
- Pythonでは並びのあるデータ集合を扱う手段として list, tuple等を利用した。
- C言語では、リストのように「後からデータを追加」「後からデータを削除（して配置し直す）」といった操作ができるデータ構造は、標準では用意されていない。
  - 自前で「リスト」や「スタック」を実装する必要がある。
    - 別の講義「アルゴリズムとデータ構造」で勉強＆実装します。
  - 今回はシーケンス集合の一例として、標準で用意されている **配列** を利用します。
    - 配列とは、「メモリ空間上に連続して並んでいるデータ構造」のこと。
    - メモリを意識して利用する必要がある。
- Pythonでのコード例: ex2.py

```
# 複数のint型要素を用意して、中身が偶数だった時は数値を出力し、奇数だった時は「奇数」と出力するプログラム。
data = [1, 2, 3]
for i in data:
    if i % 2 == 0:
        print(i)
    else:
        print('奇数')
```

- C言語でのコード例: ex2.c

```
/* 複数のint型要素を用意して、中身が偶数だった時は数値を出力し、奇数だった時は「奇数」と出力するプログラム。 */
#include <stdio.h>

int main(){
    int data[3] = {1, 2, 3}; //int data[] = {1, 2, 3}; でも良い
    int i;
    for(i=0; i<3; i++){
        if (data[i] % 2 == 0){
            printf("%d\n",data[i]);
        }else{
            printf("奇数\n");
        }
    }
    return 0;
}
```

- コード比較: Python vs C
  - ``int data[3] = {1, 2, 3};``
    - 配列を作成(用意)する際には、変数宣言時にいくつのデータを扱うのかを指定する必要がある。（上記の[3]が、3個の要素を扱うことを指定している）
    - ここで指定した要素数よりも少ない数（0〜2個）だけで利用する分には構わないが、4個以上に増やしたい場合には「**改めて必要個数を指定して配列変数を宣言**」するか、「**ポインタ**」を利用する必要がある。
      - ポインタについては「アルゴリズムとデータ構造」で解説があるとのこと。
    - 配列内の要素を参照するには ``data[0]`` のように四角カッコでインデックスを指定して参照する必要がある。（Pythonのリストと同じ）
      - インデックスは0から始まる。
      - Pythonと異なり、``data[-1]`` で一番最後の要素を参照することはできない。（**後ろからi番目の要素、という指定はNG**）
  - ``for(i=0; i<3; i++){〜〜〜}``
    - ループ文の一つ、for文の例。
    - for()のカッコ内には、(1)ループブロックを実行し始める際の初期化、(2)継続条件、(3)ループブロックを一度処理し終えた際の再初期化、の3点を記述する必要がある。
      - ``i++``は「i += 1」の意味。
      - 上記3点は省略することも可能。例えば ``for(;;){〜〜〜}`` と書くと「初期化無し、継続条件なし(=常に継続)、最初期化なし」でループブロックを実行するため、無限に反復処理し続けることになる。
        - **break; continue;** はpython同様に利用できる。
  - ``if (data[i] % 2 == 0){〜〜〜}``
    - ``data[i]`` は、配列内のデータへアクセスする例。（Pythonのリストへのアクセスとほぼ同じ）
    - if文の例。
    - **条件式は必ず丸括弧で囲う** 必要がある。
    - 条件式判定結果は「**真ならば1**」、「**偽ならば0**」となる。（**True/Falseというオブジェクトは存在しない**）
    - 複数条件の論理和を指定するなら ``条件式1 || 条件式2`` のように``||``を使う。（orは記述できない）
    - 複数条件の論理積を指定するなら``条件式1 && 条件式2`` のように``&&``を使う。（andは記述できない）
  - ``if(条件式){〜〜〜}else{〜〜〜}``
    - else文の例。
    - else時にif文を記述したい場合には``if(条件式){〜〜〜}else if{〜〜〜}``とする。（elifではない）

<hr>

### <a name="ex3">例題3: 関数を作成してみよう。</a>
- Pythonでは、関数作成のためには「def 関数名(引数):」から開始し、ブロックの中でその処理を記述する。
- C言語では、
  - (1)main()関数の前に **「戻り値の型 関数名(引数の型と呼び名);」** を記述することで、**関数プロトタイプ** を宣言する。この時点では関数の中身は記述しない。中身を記述する前に関数のプロトタイプ宣言が必要。
    - 中身を記述しないため、{}は不要。
    - プロトタイプ宣言時にはセミコロンが必要。
    - 引数については型だけの指定でも（呼び名は省略しても）構わない。
  - (2)プロトタイプ宣言後に、**「戻り値の型 関数名(引数の型と呼び名){〜〜〜}」** の形で記述し、関数を作成する。
    - 関数本体を記述する場所は、プロトタイプ宣言の後であればどこでも構わない。（main()関数の前でも後でもOK）

- Pythonでのコード例: ex3.py

```
# 100点満点採点した学生の成績をチェックし、A~F判定を返す関数。
def eval(score):
    answer = 'F'
    if score >= 90:
        answer = 'A'
    elif score >= 80:
        answer = 'B'
    elif score >= 70:
        answer = 'C'
    elif score >= 60:
        answer = 'D'
    else:
        answer = 'F'
    return answer

scores = [100, 70, 50]
for score in scores:
    answer = eval(score)
    print('{0} -> {1}'.format(score,answer))

```

- C言語でのコード例: ex3.c

```
/* 100点満点採点した学生の成績をチェックし、A~F判定を返す関数。 */
#include <stdio.h>
char eval(int score); /* 関数プロトタイプ宣言 */

/* eval関数本体
  Args:
    int score; 採点結果
  Returns:
    char; 文字型（A~F判定）
*/
char eval(int score){
    char answer = 'F';
    if (score >= 90){
        answer = 'A';
    }else if (score >= 80){
        answer = 'B';
    }else if (score >= 70){
        answer = 'C';
    }else if (score >= 60){
        answer = 'D';
    }else{
        answer = 'F';
    }
    return answer;
}

int main(){
    int scores[] = {100, 70, 50};
    int num = sizeof(scores)/sizeof(int); /*  配列scoresの要素数をカウント。 */
    int i;
    char answer;

    for(i=0; i<num; i++){
        answer = eval(scores[i]);
        printf("%d -> %c\n",scores[i],answer);
    }
}
```

- コード比較: Python vs C
  - 事前にプロトタイプ宣言が必要。
  - 関数プロトタイプと関数本体は、戻り値の型と引数の型が一致している必要がある。
  - ``char answer='F';``
    - 文字（1文字）と文字列は異なる。（そもそもC言語に文字列という型は存在しない）
    - 1文字を指定するならシングルクォーテーション``'〜'``で囲う。
      - 例えば、改行文字``'\n'``も、1文字扱いだとシングルクォーテーションで囲う必要がある。
    - 文字列を指定するならダブルクォーテーション``"〜〜"``で囲う。
      - 例えば、「hello」という5文字を変数の保存したい場合、``"hello"``と記述する必要がある。シングルクォーテーションではNG。
      - また、文字列を扱う場合、「文字はここで終了」ということを明記するための特殊文字``'\0'``（ヌル文字と呼ぶ）が必要。
        - 「hello」という5文字を保存したい場合、実際には「hello + '\0'」の6文字分のメモリが必要。このため、「hello」を保存するには``char test[6] = "hello";``と記述する必要がある。（ヌル文字は自動で付与される）
  - ``int num = sizeof(scores)/sizeof(int); /*  配列scoresの要素数をカウント。 */``
    - Pythonのlen()関数のように、要素数をカウントする関数は用意されていない。
    - sizeof()関数は、その変数が確保しているメモリをバイト数で返す関数。sizeof(int)でint型変数を1個保存するのに必要なバイト数を求め、その値で割ることで要素数を求めている。
    - sizeof(int)は統一されておらず環境により異なるため、コード中で直接記述している。
      - Pythonのint型は自動でサイズ調整してくれている。

<hr>

### <a name="ex4">例題4: 構造体を利用してみよう。</a>
- Pythonでいうところの「クラス」に近いものだが、まだクラスは扱っていないので、ここではクラスを知らない前提で話をすすめる。
- C言語で「新しい型」を作るには構造体を利用する必要がある。
  - 例えば、「学生e175701さんの成績は100点。判定結果はA。」のように、「アカウント名(文字列)、成績(数値)、判定結果(文字)」を一纏めにして処理したいことがある。これを実現するのが構造体。
  - 構造体を利用するには、
    - (1)**「struct 構造体名{〜〜〜};」** を記述することで、**構造体の型** を宣言する。
      - 構造体の型宣言時には、**{}の後にセミコロンが必要**。
    - (2)宣言後は、通常の型と同様に初期化してから利用する。

- Pythonでのコード例: ex4.py

```
# 「アカウント名、点数、判定結果」を1まとめにして扱う例。
dataset = [['e175701', 100, 'A'], ['e175702', 70, 'C'], ['e175703', 50, 'F']]

for data in dataset:
    account = data[0]
    score = data[1]
    eval = data[2]
    print('{0}さんは{1}点だったので、判定結果は{2}です！'.format(account,score,eval))
```

- C言語でのコード例: ex4.c

```
#include <stdio.h>
#include <string.h> // 文字列操作ライブラリ

/* 構造体の宣言 */
struct student_score{
    char account[8]; // "e175701"の7文字+ヌル文字分を確保。
    int score;
    char eval;
};

int main(){
    struct student_score scores[] = {{"e175701", 100, 'A'}, {"e175702", 70, 'C'}, {"e175703", 50, 'F'}};
    int num = sizeof(scores)/sizeof(struct student_score);
    char account[8];
    int score;
    char eval;

    for(int i=0; i<num; i++){
        strcpy(account, scores[i].account);
        score = scores[i].score;
        eval = scores[i].eval;
        printf("%sさんは%d点だったので、判定結果は%cです！\n",account,score,eval);
    }
}
```

- コード比較: Python vs C
  - ``#include <string.h>``
    - 文字列操作ライブラリ。文字列のコピーや連結等で利用することが多い。
  - ``struct student_score{〜〜〜};``
    - 構造体の宣言。最後にセミコロンを忘れずに。
  - ``struct student_score scores[3] = {{"e175701", 100, 'A'}, {"e175702", 70, 'C'}, {"e175703", 50, 'F'}};``
    - 構造体の初期化例。
    - 1セットのデータを{}で囲い、データ集合をカンマで区切り、更に全体を{}で囲う。
    - "e175701"（文字列）は必ずダブルクォーテーションで囲うこと。シングルクォーテーションではNG。
    - 'A'（文字）は必ずシングルクォーテーションで囲うこと。ダブルクォーテーションではNG。
  - ``for(int i=0; i<num; i++){〜〜〜}``
    - ループブロック内でのみ使用するインデックスは、上記のようにfor文記述時に変数宣言して利用することができる。ループブロックを抜けたら使用できない点に注意。
  - ``strcpy(account, scores[i].account);``
    - scores[i].accountは「構造体scoresのi番目の要素が持つ変数account」を参照。
    - strcpy(A, B)は「文字列を格納している変数Bの中身を、変数Aにコピー」する関数。
    - アドレスを指定して参照することも可能。（詳細は「アルゴリズムとデータ構造」にて）
  - ``eval = scores[i].eval;``
    - 文字列ではなく、1文字なら上記のように単に``=``を用いてコピー可能。

<hr>

## <a name="ref">参考サイト</a>
- コンパイラとインタプリタ
  - [Wikipedia:インタプリタ](https://ja.wikipedia.org/wiki/インタプリタ)
  - [Wikipedia:コンパイラ](https://ja.wikipedia.org/wiki/コンパイラ)
- C言語
  - e15以上の先輩方に教科書借りて読むのもオススメ。
    - 2015年度まで利用してたC言語の教科書: [C実践プログラミング 第3版](https://www.amazon.co.jp/C実践プログラミング-第3版-Steve-Oualline/dp/4900900648)
  - [paiza:C言語入門](https://paiza.jp/works/c/primer): 数分動画＋演習形式
  - [初心者のためのポイント学習Ｃ言語](http://www9.plala.or.jp/sgwr-t/index.html): 教科書代わり1
  - [苦しんで覚えるＣ言語(苦Ｃ)](http://9cguide.appspot.com): 教科書代わり2
- C言語/ポインタ編
  - [ポインタ虎の巻](http://www.nurs.or.jp/~sug/soft/tora/)
